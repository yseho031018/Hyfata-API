# Agora 실시간 채팅 기술 스택

**작성일:** 2025-12-02
**프로젝트:** Agora Messenger (Flutter) + Hyfata REST API (Spring Boot)

---

## 1. 개요

Agora는 Flutter 기반 메신저 앱으로, 사용자 간 실시간 채팅 기능이 필요합니다.

### 요구사항
- 실시간 메시지 송수신
- 타이핑 인디케이터 (상대방 입력 중 표시)
- 읽음 확인
- 이전 대화 내역 로드 (무한 스크롤)
- 오프라인 → 온라인 전환 시 동기화

### 아키텍처 결정
- **실시간 통신**: WebSocket + STOMP 프로토콜
- **이전 메시지 로드**: REST API (페이징)

---

## 2. 기술 스택 요약

| 구분 | 기술 | 설명 |
|------|------|------|
| **Backend** | Spring WebSocket + STOMP | 양방향 실시간 통신 |
| **Client** | `stomp_dart_client` | Flutter STOMP 클라이언트 |
| **Message Broker** | Simple Broker → Redis Pub/Sub | 단일 서버 → 멀티 서버 확장 |
| **DB** | PostgreSQL | 메시지 영구 저장 |
| **인증** | JWT | 기존 OAuth 2.0 토큰 활용 |

### 왜 STOMP인가?
- **구조화된 메시지**: JSON 기반 메시지 포맷 지원
- **토픽 기반 구독**: 채팅방별 구독/발행 패턴
- **Spring 통합**: `@MessageMapping` 어노테이션으로 간편한 핸들러 구현
- **Flutter 지원**: `stomp_dart_client` 패키지로 완벽 호환

---

## 3. 아키텍처 다이어그램

```
┌─────────────────────────────────────────────────────────────────────┐
│                         Flutter App (Agora)                         │
├─────────────────────────────────────────────────────────────────────┤
│  ChatScreen                                                         │
│  ├── REST API: 이전 메시지 로드 (GET /api/agora/chats/{id}/messages)│
│  └── WebSocket: 실시간 메시지 송수신                                 │
└──────────────────────────┬──────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────────────┐
│                    WebSocket Connection (STOMP)                     │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │ Endpoint: /ws/agora/chat                                      │  │
│  │ Subscribe: /topic/agora/chat/{chatId}                         │  │
│  │ Send: /app/agora/chat/{chatId}/send                           │  │
│  └───────────────────────────────────────────────────────────────┘  │
└──────────────────────────┬──────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────────────┐
│                      Spring Boot Server                             │
├─────────────────────────────────────────────────────────────────────┤
│  WebSocketConfig          │  JWT 인증 인터셉터                       │
│  ChatWebSocketController  │  메시지 핸들러 (@MessageMapping)         │
│  AgoraChatService         │  비즈니스 로직                           │
│  MessageRepository        │  DB 저장/조회                            │
└──────────────────────────┬──────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────────────┐
│                        PostgreSQL                                   │
│  ┌─────────┐  ┌─────────┐  ┌──────────────────┐  ┌───────────────┐  │
│  │  chats  │  │messages │  │chat_participants │  │message_read_  │  │
│  │         │  │         │  │                  │  │   status      │  │
│  └─────────┘  └─────────┘  └──────────────────┘  └───────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 4. WebSocket 엔드포인트 설계

### 연결 엔드포인트
```
ws://[서버주소]/ws/agora/chat
```

### STOMP 엔드포인트

| 용도 | 엔드포인트 | 설명 |
|------|-----------|------|
| **구독** | `/topic/agora/chat/{chatId}` | 채팅방 메시지 수신 |
| **구독** | `/user/queue/errors` | 개인 에러 메시지 수신 |
| **발행** | `/app/agora/chat/{chatId}/send` | 메시지 전송 |
| **발행** | `/app/agora/chat/{chatId}/typing` | 타이핑 상태 전송 |
| **발행** | `/app/agora/chat/{chatId}/read` | 읽음 처리 |

### 이벤트 타입
```
MESSAGE     - 새 메시지
TYPING      - 타이핑 중
READ        - 읽음 처리
USER_JOIN   - 채팅방 입장
USER_LEAVE  - 채팅방 퇴장
```

---

## 5. 메시지 형식 (JSON)

### 5.1 메시지 전송 (Client → Server)

```json
{
  "type": "MESSAGE",
  "content": "안녕하세요!",
  "messageType": "TEXT",
  "replyToId": null,
  "attachmentIds": []
}
```

### 5.2 메시지 수신 (Server → Client)

```json
{
  "type": "MESSAGE",
  "messageId": 12345,
  "chatId": 100,
  "sender": {
    "id": 1,
    "agoraId": "user123",
    "displayName": "홍길동",
    "profileImage": "https://..."
  },
  "content": "안녕하세요!",
  "messageType": "TEXT",
  "replyTo": null,
  "attachments": [],
  "createdAt": "2025-12-02T10:30:00Z"
}
```

### 5.3 타이핑 이벤트

```json
{
  "type": "TYPING",
  "userId": 1,
  "displayName": "홍길동",
  "isTyping": true
}
```

### 5.4 읽음 이벤트

```json
{
  "type": "READ",
  "userId": 1,
  "lastReadMessageId": 12345,
  "readAt": "2025-12-02T10:31:00Z"
}
```

---

## 6. 메시지 히스토리 로드 (REST API)

WebSocket은 실시간 메시지만 처리합니다. 이전 대화 내역은 REST API로 로드합니다.

### 6.1 API 엔드포인트

```
GET /api/agora/chats/{chatId}/messages
```

### 6.2 요청 파라미터

| 파라미터 | 타입 | 필수 | 설명 |
|---------|------|------|------|
| `cursor` | Long | N | 마지막 메시지 ID (이전 메시지 로드 시) |
| `limit` | Integer | N | 가져올 개수 (기본값: 20, 최대: 50) |
| `direction` | String | N | `before` (기본값) 또는 `after` |

### 6.3 응답 예시

```json
{
  "success": true,
  "data": {
    "messages": [
      {
        "id": 12340,
        "sender": {
          "id": 2,
          "agoraId": "user456",
          "displayName": "김철수",
          "profileImage": "https://..."
        },
        "content": "이전 메시지입니다",
        "messageType": "TEXT",
        "replyTo": null,
        "attachments": [],
        "isDeleted": false,
        "createdAt": "2025-12-02T10:00:00Z"
      }
    ],
    "hasMore": true,
    "nextCursor": 12339
  }
}
```

### 6.4 Spring Boot Controller

```java
@RestController
@RequestMapping("/api/agora/chats")
@RequiredArgsConstructor
public class AgoraChatController {

    private final AgoraChatService chatService;

    @GetMapping("/{chatId}/messages")
    public ResponseEntity<ApiResponse<MessagePageResponse>> getMessages(
            @PathVariable Long chatId,
            @RequestParam(required = false) Long cursor,
            @RequestParam(defaultValue = "20") @Max(50) Integer limit,
            @RequestParam(defaultValue = "before") String direction,
            @AuthenticationPrincipal User user) {

        // 채팅방 접근 권한 확인
        chatService.validateChatAccess(chatId, user.getId());

        MessagePageResponse response = chatService.getMessages(
            chatId, cursor, limit, direction
        );

        return ResponseEntity.ok(ApiResponse.success(response));
    }
}
```

### 6.5 Service 구현

```java
@Service
@RequiredArgsConstructor
public class AgoraChatServiceImpl implements AgoraChatService {

    private final MessageRepository messageRepository;
    private final ChatParticipantRepository participantRepository;

    @Override
    @Transactional(readOnly = true)
    public MessagePageResponse getMessages(Long chatId, Long cursor,
                                           Integer limit, String direction) {
        List<Message> messages;

        if (cursor == null) {
            // 최신 메시지부터 로드
            messages = messageRepository.findByChatIdOrderByIdDesc(
                chatId, PageRequest.of(0, limit + 1)
            );
        } else if ("before".equals(direction)) {
            // cursor보다 이전 메시지
            messages = messageRepository.findByChatIdAndIdLessThanOrderByIdDesc(
                chatId, cursor, PageRequest.of(0, limit + 1)
            );
        } else {
            // cursor보다 이후 메시지
            messages = messageRepository.findByChatIdAndIdGreaterThanOrderByIdAsc(
                chatId, cursor, PageRequest.of(0, limit + 1)
            );
        }

        boolean hasMore = messages.size() > limit;
        if (hasMore) {
            messages = messages.subList(0, limit);
        }

        Long nextCursor = messages.isEmpty() ? null :
            messages.get(messages.size() - 1).getId();

        return MessagePageResponse.builder()
            .messages(messages.stream()
                .map(MessageDto::from)
                .collect(Collectors.toList()))
            .hasMore(hasMore)
            .nextCursor(nextCursor)
            .build();
    }

    @Override
    public void validateChatAccess(Long chatId, Long userId) {
        boolean isParticipant = participantRepository
            .existsByChatIdAndUserId(chatId, userId);

        if (!isParticipant) {
            throw new AccessDeniedException("채팅방에 접근 권한이 없습니다.");
        }
    }
}
```

### 6.6 Flutter에서 호출

```dart
class ChatRepository {
  final Dio _dio;

  ChatRepository(this._dio);

  Future<MessagePageResponse> getMessages({
    required int chatId,
    int? cursor,
    int limit = 20,
  }) async {
    final response = await _dio.get(
      '/api/agora/chats/$chatId/messages',
      queryParameters: {
        if (cursor != null) 'cursor': cursor,
        'limit': limit,
        'direction': 'before',
      },
    );

    return MessagePageResponse.fromJson(response.data['data']);
  }
}

// 사용 예시 (무한 스크롤)
class ChatBloc {
  int? _lastCursor;
  bool _hasMore = true;

  Future<void> loadMoreMessages() async {
    if (!_hasMore) return;

    final response = await _chatRepository.getMessages(
      chatId: _chatId,
      cursor: _lastCursor,
    );

    _messages.insertAll(0, response.messages);
    _hasMore = response.hasMore;
    _lastCursor = response.nextCursor;
  }
}
```

---

## 7. Spring Boot 구현

### 7.1 의존성 추가 (build.gradle)

```groovy
dependencies {
    // WebSocket
    implementation 'org.springframework.boot:spring-boot-starter-websocket'

    // 기존 의존성
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
}
```

### 7.2 WebSocketConfig.java

```java
package kr.hyfata.rest.api.config;

import kr.hyfata.rest.api.security.JwtChannelInterceptor;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.ChannelRegistration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;

@Configuration
@EnableWebSocketMessageBroker
@RequiredArgsConstructor
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    private final JwtChannelInterceptor jwtChannelInterceptor;

    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        // 클라이언트가 구독할 prefix
        config.enableSimpleBroker("/topic", "/queue");

        // 클라이언트가 메시지를 보낼 prefix
        config.setApplicationDestinationPrefixes("/app");

        // 특정 사용자에게 메시지 전송 시 prefix
        config.setUserDestinationPrefix("/user");
    }

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/ws/agora/chat")
                .setAllowedOriginPatterns("*")
                .withSockJS(); // SockJS 폴백 지원
    }

    @Override
    public void configureClientInboundChannel(ChannelRegistration registration) {
        // JWT 인증 인터셉터 등록
        registration.interceptors(jwtChannelInterceptor);
    }
}
```

### 7.3 JWT 인증 인터셉터

```java
package kr.hyfata.rest.api.security;

import kr.hyfata.rest.api.util.JwtUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.simp.stomp.StompCommand;
import org.springframework.messaging.simp.stomp.StompHeaderAccessor;
import org.springframework.messaging.support.ChannelInterceptor;
import org.springframework.messaging.support.MessageHeaderAccessor;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.stereotype.Component;

@Slf4j
@Component
@RequiredArgsConstructor
public class JwtChannelInterceptor implements ChannelInterceptor {

    private final JwtUtil jwtUtil;
    private final UserDetailsService userDetailsService;

    @Override
    public Message<?> preSend(Message<?> message, MessageChannel channel) {
        StompHeaderAccessor accessor = MessageHeaderAccessor
            .getAccessor(message, StompHeaderAccessor.class);

        if (accessor != null && StompCommand.CONNECT.equals(accessor.getCommand())) {
            String authHeader = accessor.getFirstNativeHeader("Authorization");

            if (authHeader != null && authHeader.startsWith("Bearer ")) {
                String token = authHeader.substring(7);

                try {
                    String username = jwtUtil.extractUsername(token);

                    if (username != null && jwtUtil.isTokenValid(token)) {
                        UserDetails userDetails = userDetailsService
                            .loadUserByUsername(username);

                        UsernamePasswordAuthenticationToken authentication =
                            new UsernamePasswordAuthenticationToken(
                                userDetails,
                                null,
                                userDetails.getAuthorities()
                            );

                        accessor.setUser(authentication);
                        log.info("WebSocket 연결 인증 성공: {}", username);
                    }
                } catch (Exception e) {
                    log.error("WebSocket 인증 실패: {}", e.getMessage());
                    throw new IllegalArgumentException("Invalid JWT token");
                }
            } else {
                log.warn("WebSocket 연결에 Authorization 헤더 없음");
                throw new IllegalArgumentException("Authorization header required");
            }
        }

        return message;
    }
}
```

### 7.4 ChatWebSocketController.java

```java
package kr.hyfata.rest.api.controller.agora;

import kr.hyfata.rest.api.dto.agora.chat.*;
import kr.hyfata.rest.api.entity.User;
import kr.hyfata.rest.api.service.agora.AgoraChatService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.messaging.handler.annotation.DestinationVariable;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.handler.annotation.Payload;
import org.springframework.messaging.simp.SimpMessageHeaderAccessor;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.stereotype.Controller;

import java.security.Principal;

@Slf4j
@Controller
@RequiredArgsConstructor
public class ChatWebSocketController {

    private final SimpMessagingTemplate messagingTemplate;
    private final AgoraChatService chatService;

    /**
     * 메시지 전송
     * Client → /app/agora/chat/{chatId}/send
     * Server → /topic/agora/chat/{chatId}
     */
    @MessageMapping("/agora/chat/{chatId}/send")
    public void sendMessage(
            @DestinationVariable Long chatId,
            @Payload SendMessageRequest request,
            Principal principal) {

        User user = extractUser(principal);
        log.info("메시지 수신 - chatId: {}, userId: {}", chatId, user.getId());

        // 채팅방 접근 권한 확인
        chatService.validateChatAccess(chatId, user.getId());

        // 메시지 저장 및 DTO 변환
        ChatMessageDto messageDto = chatService.saveAndBroadcastMessage(
            chatId, user, request
        );

        // 채팅방 구독자들에게 브로드캐스트
        messagingTemplate.convertAndSend(
            "/topic/agora/chat/" + chatId,
            messageDto
        );
    }

    /**
     * 타이핑 상태 전송
     * Client → /app/agora/chat/{chatId}/typing
     * Server → /topic/agora/chat/{chatId}
     */
    @MessageMapping("/agora/chat/{chatId}/typing")
    public void sendTypingStatus(
            @DestinationVariable Long chatId,
            @Payload TypingStatusRequest request,
            Principal principal) {

        User user = extractUser(principal);

        TypingStatusDto typingStatus = TypingStatusDto.builder()
            .type("TYPING")
            .userId(user.getId())
            .displayName(chatService.getUserDisplayName(user.getId()))
            .isTyping(request.isTyping())
            .build();

        messagingTemplate.convertAndSend(
            "/topic/agora/chat/" + chatId,
            typingStatus
        );
    }

    /**
     * 읽음 처리
     * Client → /app/agora/chat/{chatId}/read
     * Server → /topic/agora/chat/{chatId}
     */
    @MessageMapping("/agora/chat/{chatId}/read")
    public void markAsRead(
            @DestinationVariable Long chatId,
            @Payload ReadStatusRequest request,
            Principal principal) {

        User user = extractUser(principal);

        // 읽음 상태 저장
        ReadStatusDto readStatus = chatService.markMessagesAsRead(
            chatId, user.getId(), request.getLastReadMessageId()
        );

        // 상대방에게 읽음 알림
        messagingTemplate.convertAndSend(
            "/topic/agora/chat/" + chatId,
            readStatus
        );
    }

    private User extractUser(Principal principal) {
        if (principal instanceof UsernamePasswordAuthenticationToken auth) {
            return (User) auth.getPrincipal();
        }
        throw new IllegalStateException("인증 정보를 찾을 수 없습니다.");
    }
}
```

### 7.5 DTO 클래스들

```java
// SendMessageRequest.java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class SendMessageRequest {
    private String type = "MESSAGE";
    private String content;
    private String messageType = "TEXT"; // TEXT, IMAGE, FILE
    private Long replyToId;
    private List<Long> attachmentIds = new ArrayList<>();
}

// ChatMessageDto.java
@Data
@Builder
public class ChatMessageDto {
    private String type;
    private Long messageId;
    private Long chatId;
    private SenderDto sender;
    private String content;
    private String messageType;
    private ChatMessageDto replyTo;
    private List<AttachmentDto> attachments;
    private LocalDateTime createdAt;
}

// TypingStatusDto.java
@Data
@Builder
public class TypingStatusDto {
    private String type;
    private Long userId;
    private String displayName;
    private boolean isTyping;
}

// ReadStatusDto.java
@Data
@Builder
public class ReadStatusDto {
    private String type;
    private Long userId;
    private Long lastReadMessageId;
    private LocalDateTime readAt;
}
```

---

## 8. Flutter 클라이언트 구현

### 8.1 패키지 추가 (pubspec.yaml)

```yaml
dependencies:
  stomp_dart_client: ^1.0.0
  web_socket_channel: ^2.4.0
```

### 8.2 ChatSocketService.dart

```dart
import 'dart:async';
import 'dart:convert';
import 'package:stomp_dart_client/stomp_dart_client.dart';

class ChatSocketService {
  StompClient? _stompClient;
  final String _baseUrl;
  final String _accessToken;

  final _messageController = StreamController<ChatMessage>.broadcast();
  final _typingController = StreamController<TypingStatus>.broadcast();
  final _readController = StreamController<ReadStatus>.broadcast();
  final _connectionController = StreamController<bool>.broadcast();

  Stream<ChatMessage> get messageStream => _messageController.stream;
  Stream<TypingStatus> get typingStream => _typingController.stream;
  Stream<ReadStatus> get readStream => _readController.stream;
  Stream<bool> get connectionStream => _connectionController.stream;

  final Map<int, StompUnsubscribe> _subscriptions = {};
  bool _isConnected = false;

  ChatSocketService({
    required String baseUrl,
    required String accessToken,
  }) : _baseUrl = baseUrl,
       _accessToken = accessToken;

  /// WebSocket 연결
  Future<void> connect() async {
    if (_isConnected) return;

    final wsUrl = _baseUrl.replaceFirst('http', 'ws');

    _stompClient = StompClient(
      config: StompConfig(
        url: '$wsUrl/ws/agora/chat/websocket',
        stompConnectHeaders: {
          'Authorization': 'Bearer $_accessToken',
        },
        webSocketConnectHeaders: {
          'Authorization': 'Bearer $_accessToken',
        },
        onConnect: _onConnect,
        onDisconnect: _onDisconnect,
        onStompError: _onStompError,
        onWebSocketError: _onWebSocketError,
        reconnectDelay: const Duration(seconds: 5),
      ),
    );

    _stompClient!.activate();
  }

  void _onConnect(StompFrame frame) {
    _isConnected = true;
    _connectionController.add(true);
    print('WebSocket 연결 성공');
  }

  void _onDisconnect(StompFrame frame) {
    _isConnected = false;
    _connectionController.add(false);
    print('WebSocket 연결 해제');
  }

  void _onStompError(StompFrame frame) {
    print('STOMP 에러: ${frame.body}');
    _connectionController.add(false);
  }

  void _onWebSocketError(dynamic error) {
    print('WebSocket 에러: $error');
    _connectionController.add(false);
  }

  /// 채팅방 구독
  void subscribeToChatRoom(int chatId) {
    if (_stompClient == null || !_isConnected) {
      print('WebSocket 미연결 상태');
      return;
    }

    // 이미 구독 중인 경우 스킵
    if (_subscriptions.containsKey(chatId)) return;

    final unsubscribe = _stompClient!.subscribe(
      destination: '/topic/agora/chat/$chatId',
      callback: (frame) => _handleMessage(frame, chatId),
    );

    _subscriptions[chatId] = unsubscribe;
    print('채팅방 $chatId 구독 시작');
  }

  /// 채팅방 구독 해제
  void unsubscribeFromChatRoom(int chatId) {
    final unsubscribe = _subscriptions.remove(chatId);
    if (unsubscribe != null) {
      unsubscribe();
      print('채팅방 $chatId 구독 해제');
    }
  }

  void _handleMessage(StompFrame frame, int chatId) {
    if (frame.body == null) return;

    try {
      final data = jsonDecode(frame.body!);
      final type = data['type'] as String;

      switch (type) {
        case 'MESSAGE':
          _messageController.add(ChatMessage.fromJson(data));
          break;
        case 'TYPING':
          _typingController.add(TypingStatus.fromJson(data));
          break;
        case 'READ':
          _readController.add(ReadStatus.fromJson(data));
          break;
        default:
          print('알 수 없는 메시지 타입: $type');
      }
    } catch (e) {
      print('메시지 파싱 에러: $e');
    }
  }

  /// 메시지 전송
  void sendMessage({
    required int chatId,
    required String content,
    String messageType = 'TEXT',
    int? replyToId,
    List<int>? attachmentIds,
  }) {
    if (_stompClient == null || !_isConnected) {
      throw Exception('WebSocket 미연결 상태');
    }

    final message = {
      'type': 'MESSAGE',
      'content': content,
      'messageType': messageType,
      'replyToId': replyToId,
      'attachmentIds': attachmentIds ?? [],
    };

    _stompClient!.send(
      destination: '/app/agora/chat/$chatId/send',
      body: jsonEncode(message),
    );
  }

  /// 타이핑 상태 전송
  void sendTypingStatus({
    required int chatId,
    required bool isTyping,
  }) {
    if (_stompClient == null || !_isConnected) return;

    _stompClient!.send(
      destination: '/app/agora/chat/$chatId/typing',
      body: jsonEncode({'isTyping': isTyping}),
    );
  }

  /// 읽음 처리
  void markAsRead({
    required int chatId,
    required int lastReadMessageId,
  }) {
    if (_stompClient == null || !_isConnected) return;

    _stompClient!.send(
      destination: '/app/agora/chat/$chatId/read',
      body: jsonEncode({'lastReadMessageId': lastReadMessageId}),
    );
  }

  /// 연결 해제
  void disconnect() {
    // 모든 구독 해제
    for (final unsubscribe in _subscriptions.values) {
      unsubscribe();
    }
    _subscriptions.clear();

    // 연결 종료
    _stompClient?.deactivate();
    _isConnected = false;
  }

  /// 리소스 정리
  void dispose() {
    disconnect();
    _messageController.close();
    _typingController.close();
    _readController.close();
    _connectionController.close();
  }
}
```

### 8.3 모델 클래스

```dart
// chat_message.dart
class ChatMessage {
  final String type;
  final int messageId;
  final int chatId;
  final Sender sender;
  final String content;
  final String messageType;
  final ChatMessage? replyTo;
  final List<Attachment> attachments;
  final DateTime createdAt;

  ChatMessage({
    required this.type,
    required this.messageId,
    required this.chatId,
    required this.sender,
    required this.content,
    required this.messageType,
    this.replyTo,
    required this.attachments,
    required this.createdAt,
  });

  factory ChatMessage.fromJson(Map<String, dynamic> json) {
    return ChatMessage(
      type: json['type'],
      messageId: json['messageId'],
      chatId: json['chatId'],
      sender: Sender.fromJson(json['sender']),
      content: json['content'],
      messageType: json['messageType'],
      replyTo: json['replyTo'] != null
          ? ChatMessage.fromJson(json['replyTo'])
          : null,
      attachments: (json['attachments'] as List)
          .map((e) => Attachment.fromJson(e))
          .toList(),
      createdAt: DateTime.parse(json['createdAt']),
    );
  }
}

// typing_status.dart
class TypingStatus {
  final String type;
  final int userId;
  final String displayName;
  final bool isTyping;

  TypingStatus({
    required this.type,
    required this.userId,
    required this.displayName,
    required this.isTyping,
  });

  factory TypingStatus.fromJson(Map<String, dynamic> json) {
    return TypingStatus(
      type: json['type'],
      userId: json['userId'],
      displayName: json['displayName'],
      isTyping: json['isTyping'],
    );
  }
}

// read_status.dart
class ReadStatus {
  final String type;
  final int userId;
  final int lastReadMessageId;
  final DateTime readAt;

  ReadStatus({
    required this.type,
    required this.userId,
    required this.lastReadMessageId,
    required this.readAt,
  });

  factory ReadStatus.fromJson(Map<String, dynamic> json) {
    return ReadStatus(
      type: json['type'],
      userId: json['userId'],
      lastReadMessageId: json['lastReadMessageId'],
      readAt: DateTime.parse(json['readAt']),
    );
  }
}
```

### 8.4 사용 예시 (ChatScreen)

```dart
class ChatScreen extends StatefulWidget {
  final int chatId;
  const ChatScreen({required this.chatId});

  @override
  _ChatScreenState createState() => _ChatScreenState();
}

class _ChatScreenState extends State<ChatScreen> {
  late ChatSocketService _socketService;
  late ChatRepository _chatRepository;

  final List<ChatMessage> _messages = [];
  final _messageController = TextEditingController();
  final _scrollController = ScrollController();

  int? _lastCursor;
  bool _hasMore = true;
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    _initServices();
    _loadInitialMessages();
    _setupScrollListener();
  }

  void _initServices() {
    final authProvider = context.read<AuthProvider>();

    _socketService = ChatSocketService(
      baseUrl: 'https://api.example.com',
      accessToken: authProvider.accessToken!,
    );

    _chatRepository = ChatRepository(authProvider.dio);

    // WebSocket 연결 및 구독
    _socketService.connect().then((_) {
      _socketService.subscribeToChatRoom(widget.chatId);
    });

    // 실시간 메시지 수신
    _socketService.messageStream.listen((message) {
      setState(() {
        _messages.add(message);
      });
      _scrollToBottom();
    });
  }

  Future<void> _loadInitialMessages() async {
    setState(() => _isLoading = true);

    final response = await _chatRepository.getMessages(
      chatId: widget.chatId,
      limit: 20,
    );

    setState(() {
      _messages.insertAll(0, response.messages);
      _hasMore = response.hasMore;
      _lastCursor = response.nextCursor;
      _isLoading = false;
    });
  }

  void _setupScrollListener() {
    _scrollController.addListener(() {
      // 스크롤이 맨 위에 도달하면 이전 메시지 로드
      if (_scrollController.position.pixels == 0 && _hasMore && !_isLoading) {
        _loadMoreMessages();
      }
    });
  }

  Future<void> _loadMoreMessages() async {
    if (!_hasMore || _isLoading) return;

    setState(() => _isLoading = true);

    final response = await _chatRepository.getMessages(
      chatId: widget.chatId,
      cursor: _lastCursor,
      limit: 20,
    );

    setState(() {
      _messages.insertAll(0, response.messages);
      _hasMore = response.hasMore;
      _lastCursor = response.nextCursor;
      _isLoading = false;
    });
  }

  void _sendMessage() {
    final content = _messageController.text.trim();
    if (content.isEmpty) return;

    _socketService.sendMessage(
      chatId: widget.chatId,
      content: content,
    );

    _messageController.clear();
  }

  void _scrollToBottom() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _scrollController.animateTo(
        _scrollController.position.maxScrollExtent,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeOut,
      );
    });
  }

  @override
  void dispose() {
    _socketService.unsubscribeFromChatRoom(widget.chatId);
    _socketService.dispose();
    _messageController.dispose();
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('채팅')),
      body: Column(
        children: [
          // 메시지 목록
          Expanded(
            child: ListView.builder(
              controller: _scrollController,
              itemCount: _messages.length + (_isLoading ? 1 : 0),
              itemBuilder: (context, index) {
                if (_isLoading && index == 0) {
                  return Center(child: CircularProgressIndicator());
                }
                final msgIndex = _isLoading ? index - 1 : index;
                return MessageBubble(message: _messages[msgIndex]);
              },
            ),
          ),
          // 입력창
          _buildInputArea(),
        ],
      ),
    );
  }

  Widget _buildInputArea() {
    return Container(
      padding: const EdgeInsets.all(8),
      child: Row(
        children: [
          Expanded(
            child: TextField(
              controller: _messageController,
              decoration: InputDecoration(
                hintText: '메시지 입력...',
                border: OutlineInputBorder(),
              ),
              onChanged: (_) {
                _socketService.sendTypingStatus(
                  chatId: widget.chatId,
                  isTyping: true,
                );
              },
            ),
          ),
          IconButton(
            icon: Icon(Icons.send),
            onPressed: _sendMessage,
          ),
        ],
      ),
    );
  }
}
```

---

## 9. 인증/보안

### 9.1 WebSocket 인증 흐름

```
1. Flutter 앱에서 JWT Access Token 획득 (OAuth 2.0)
2. WebSocket 연결 시 Authorization 헤더에 토큰 포함
3. Spring JwtChannelInterceptor에서 CONNECT 시 토큰 검증
4. 유효한 토큰인 경우 Principal 설정
5. 이후 메시지 핸들러에서 Principal로 사용자 식별
```

### 9.2 채팅방 접근 권한 검증

```java
@Override
public void validateChatAccess(Long chatId, Long userId) {
    boolean isParticipant = chatParticipantRepository
        .existsByChatIdAndUserId(chatId, userId);

    if (!isParticipant) {
        throw new AccessDeniedException("채팅방에 접근 권한이 없습니다.");
    }
}
```

### 9.3 토큰 만료 처리 (Flutter)

```dart
_socketService.connectionStream.listen((isConnected) {
  if (!isConnected) {
    // 토큰 갱신 후 재연결 시도
    _refreshTokenAndReconnect();
  }
});

Future<void> _refreshTokenAndReconnect() async {
  try {
    await authProvider.refreshToken();

    // 새 토큰으로 소켓 서비스 재생성
    _socketService = ChatSocketService(
      baseUrl: 'https://api.example.com',
      accessToken: authProvider.accessToken!,
    );

    await _socketService.connect();
    _socketService.subscribeToChatRoom(widget.chatId);
  } catch (e) {
    // 재인증 필요
    Navigator.pushReplacementNamed(context, '/login');
  }
}
```

---

## 10. 현재 엔티티 구조

프로젝트에 이미 정의된 채팅 관련 엔티티입니다.

### 엔티티 관계도

```
Chat (채팅방)
├── id: Long (PK)
├── type: ChatType (DIRECT, GROUP)
├── name: String
├── profileImage: String
├── readEnabled: Boolean
├── createdBy: User (FK)
├── participants: List<ChatParticipant>
└── messages: List<Message>

Message (메시지)
├── id: Long (PK)
├── chat: Chat (FK)
├── sender: User (FK)
├── content: String
├── type: MessageType (TEXT, IMAGE, FILE, SYSTEM)
├── replyTo: Message (FK, nullable)
├── isDeleted: Boolean
├── isPinned: Boolean
├── attachments: List<MessageAttachment>
└── readStatuses: List<MessageReadStatus>

ChatParticipant (채팅 참여자)
├── id: Long (PK)
├── chat: Chat (FK)
├── user: User (FK)
├── role: Role (ADMIN, MEMBER)
├── isPinned: Boolean
└── joinedAt: LocalDateTime

MessageReadStatus (읽음 상태)
├── id: Long (PK)
├── message: Message (FK)
└── user: User (FK)

MessageAttachment (첨부파일)
├── id: Long (PK)
├── message: Message (FK)
├── file: AgoraFile (FK)
└── orderIndex: Integer
```

---

## 11. 확장 고려사항

### 11.1 Redis Pub/Sub 전환 시점

현재 Simple Broker는 단일 서버 환경에 적합합니다. 다음 상황에서 Redis로 전환을 고려하세요:

- 서버 인스턴스가 2대 이상으로 확장될 때
- 동시 접속자 1,000명 이상 예상될 때

### 11.2 Redis 설정 예시

```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        config.enableStompBrokerRelay("/topic", "/queue")
              .setRelayHost("localhost")
              .setRelayPort(61613)
              .setClientLogin("guest")
              .setClientPasscode("guest");

        config.setApplicationDestinationPrefixes("/app");
        config.setUserDestinationPrefix("/user");
    }
}
```

### 11.3 추가 고려사항

- **메시지 압축**: 대용량 메시지의 경우 gzip 압축 적용
- **Rate Limiting**: 스팸 방지를 위한 메시지 전송 제한
- **메시지 암호화**: E2E 암호화가 필요한 경우 별도 구현
- **오프라인 메시지**: 푸시 알림 연동 (FCM)

---

**최종 수정:** 2025-12-02
**버전:** 1.0
